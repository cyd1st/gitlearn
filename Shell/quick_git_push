#!/bin/bash
# 功能：一键提交当前仓库的修改到远程仓库

# ANSI 转义码定义
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 定义默认的提交信息
DEFAULT_MESSAGE='sync.'

# 解析命令行参数
while getopts ":m:" opt; do
  case $opt in
    m)
      COMMIT_MESSAGE="$OPTARG"
      ;;
    \?)
      echo -e "${RED}无效选项: -$OPTARG${NC}" >&2
      exit 1
      ;;
    :)
      echo -e "${RED}选项 -$OPTARG 需要参数.${NC}" >&2
      exit 1
      ;;
  esac
done

# 移除已解析的选项，避免影响后续的命令
shift $((OPTIND-1))

# 如果没有提供 -m 参数，使用默认提交信息
[ -z "$COMMIT_MESSAGE" ] && COMMIT_MESSAGE=$DEFAULT_MESSAGE

# 检查是否在 gitlearn 仓库中
GIT_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
if [ "$(basename "$GIT_ROOT")" != "gitlearn" ]; then
    # 如果当前不在 gitlearn 仓库中，打印错误信息并退出
    echo -e "${RED}当前不在 gitlearn 仓库内${NC}"
    exit 1
fi

# 保存当前目录
ORIGINAL_DIR="$PWD"
# 切换到 gitlearn 的根目录（在子目录执行可能提交不全）
cd "$GIT_ROOT"

# 检查是否有文件更改
CHANGES=$(git status --porcelain)
if [ -z "$CHANGES" ]; then
    # 如果没有文件更改，打印信息并退出
    echo -e "${GREEN}没有文件修改需要提交${NC}"
    exit 0
fi

# 显示所有有变更的文件
echo -e "${BLUE}以下文件有变更：${NC}"
git status --short

# 执行 git add .
echo -e "${GREEN}正在添加所有更改到暂存区...${NC}"
git add .

# 执行 git commit -m "$COMMIT_MESSAGE"
echo -e "${GREEN}正在提交更改...${NC}"
if ! git commit -m "$COMMIT_MESSAGE"; then
    echo -e "${YELLOW}提交失败或没有可提交的更改，请检查后重试${NC}"
    # 返回初始目录
    cd "$ORIGINAL_DIR"
    exit 1
fi

# 检查是否有远程仓库可以推送
REMOTE=$(git config --get remote.origin.url)
if [ -z "$REMOTE" ]; then
    # 如果没有远程仓库，打印错误信息并退出
    echo -e "${RED}没有检测到远程仓库${NC}"
    # 返回初始目录
    cd "$ORIGINAL_DIR"
    exit 1
fi

# 获取当前分支
BRANCH=$(git rev-parse --abbrev-ref HEAD)
echo -e "${BLUE}当前分支: ${BRANCH}${NC}"

# 获取远端信息
echo -e "${GREEN}正在从远程获取最新信息...${NC}"
git fetch origin

# 比较本地与远程状态
LOCAL_HASH=$(git rev-parse @)
REMOTE_HASH=$(git rev-parse "origin/$BRANCH" 2>/dev/null || true)
BASE_HASH=$(git merge-base @ "origin/$BRANCH" 2>/dev/null || true)

if [ "$REMOTE_HASH" = "" ]; then
    echo -e "${YELLOW}远程不存在分支 origin/${BRANCH}，将直接推送本地分支${NC}"
elif [ "$LOCAL_HASH" = "$REMOTE_HASH" ]; then
    echo -e "${GREEN}本地与远程已同步${NC}"
elif [ "$LOCAL_HASH" = "$BASE_HASH" ]; then
    # 本地落后，尝试自动 rebase
    echo -e "${YELLOW}本地落后于远程，尝试拉取并 rebase（推荐）...${NC}"
    if ! git pull --rebase --autostash origin "$BRANCH"; then
        echo -e "${RED}自动 rebase 失败，请手动解决冲突后再运行脚本${NC}"
        # 返回初始目录
        cd "$ORIGINAL_DIR"
        exit 1
    fi
elif [ "$REMOTE_HASH" = "$BASE_HASH" ]; then
    echo -e "${GREEN}本地领先于远程，准备推送...${NC}"
else
    echo -e "${RED}本地与远端出现分叉，需要手动合并或 rebase（脚本中止）${NC}"
    echo -e "${BLUE}建议： git fetch origin && git rebase origin/${BRANCH} 或手动合并并解决冲突${NC}"
    # 返回初始目录
    cd "$ORIGINAL_DIR"
    exit 1
fi

# 执行推送（优先普通推送，必要时使用 --force-with-lease）
echo -e "${GREEN}正在推送到远程仓库...${NC}"
if ! git push --porcelain origin "$BRANCH" 2>&1; then
    echo -e "${YELLOW}普通推送失败，尝试使用 --force-with-lease（安全强制推送）...${NC}"
    if ! git push --force-with-lease origin "$BRANCH"; then
        echo -e "${RED}推送失败，请检查权限或远程分支状态${NC}"
        # 返回初始目录
        cd "$ORIGINAL_DIR"
        exit 1
    fi
fi

# 如果脚本运行到这里，说明一切正常
echo -e "${GREEN}操作完成！${NC}"

# 返回初始目录
cd "$ORIGINAL_DIR"


# 功能介绍：
#	1. 判断当时是否有效目录。
#		a. 是否gitlearn目录
#		b. 是否git仓库
#	2. 可选参数 -m，用于替换 git commit -m 的内容。
#		不选该参数，默认为 'sync'
#	3. 判断是否有文件变更，没有打印提示并结束运行。
#		并且可以列出变更文件。
#	4. 判断仓库是否有效（可push）
#	5. 保存变更并提交到远程。
#       添加输出提示语颜色等格式
